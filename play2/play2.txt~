Play2 with Scala
===============
:encoding: UTF-8
:numbered:
:iconsdir: /usr/local/etc/asciidoc/images/icons/


İçerik
------
    * Basitçe Play2 
    * Play1.x'den farkı
    * Neden Scala
    * Asenkron yapı
    * Iteratees
    * ReactiveMongo

Play2
-----

Neden Play?
~~~~~~~~~~~

.Fully non-blocking/asynchronous
Request ler threadleri bloklamaz. Bu sayade bir thread birden fazla isteğe cevap verebilir.

.Stateless
Server tarafında hiçbir state bilgisi tutulmaz.

.RESTful
Client-Server iletişimi HTTP protokolü üzerinden sağlanır.

.Instant reloading
Kod değişikliğinizi sayfayı yenileyerek görebilirsiniz.

.Template engine
HTML, XML gibi text tabanlı döküman oluşturmak için kullanılır.

.HTTP routing
Gelen HTTP Requestler ilgli Actionlara yönlendirilir.

.Full stack framework
//TODO

Sistem Akışı
~~~~~~~~~~~~

image:request.png[]

Play 1, Ne değişti?
~~~~~~~~~~~~~~~~~~~

.Scala :)
* Başlangıçta Scala desteği için bir modül tasarlandı.
** Template Engine ve Anorm bu sıralar geliştirildi.
* Daha sonra dilden maksimum yararlanmak için çekirdeğe taşımasına karar verildi.

.Template engine
* Groovy'den Scala tabanlı Template engine'e geçildi.
** ASP.NET Razor'dan ilham alınmış.

.Type safety
* Template engine Scalada yazıldığı için Compile time test yapılabiliyor.
* Routing/ReverseRouting de artık typesafe.
* Compile time'da kontrolün bir avantaji da performans artışı.

.Build system
Play 1.x de Python scripleriyle hallediliyordu. Artık sbt(scala built tool) var.

Asenkron Yapı
-------------

Uygulama herhangi bir sonuç beklemeden, hiçbir thread bloklanmadan çalışır.

* Uzun sürecek bir işlemin sonucunun elinize geleceğini varsılır.
* Sonuç beklemek threadi blocklayacağından asenkron yapı kullanılır. 
** asenkron: Bloklanan threatler olabilir. Fakat sorguyu yapan bloklanmaz.
** non-blocking: Hiçbir thread bloklanmaz.

Henüz var olmayan veriyi kullanmak
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Gelecek değer yerine o değerin geleceğine dair bir promise kullanılır.( Promise[Result] )

----
val promiseOfInt: Promise[Int] = Akka.future {
  intensiveComputation()
}
----

Promise değeri asenkron olarak kullanmak
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Geleceği varsayılan değeri kullanmak için Async yapı oluşturulur.

----
def index = Action {
  val promiseOfInt = Akka.future { intensiveComputation() }
  Async {
    promiseOfInt.map(i => Ok("Got result: " + i))
  }
}
----


 
Iteratees
---------
Nedir, ne işe yarar?
~~~~~~~~~~~~~~~~~~~~
Enumerator (produce data) → Enumeratee (map data) → Iteratee (consume data)








ReactiveMongo
-------------



Bağlantılar
-----------

- http://www.playframework.org
- http://groups.google.com/group/play-framework
- http://groups.google.com/group/play-framework-tr
- http://www.reactivemongo.org
- http://fehmicansaglam.net

.Further reading
- https://groups.google.com/forum/?fromgroups=#!topic/play-framework/DwSkWwTT9Wk
- http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/
- http://engineering.klout.com/2013/01/iteratees-in-big-data-at-klout/